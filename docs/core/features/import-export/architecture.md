# Import/Export System - Architecture

**Document Version:** 1.0  
**Last Updated:** 2026-01-05  
**Status:** üìã DESIGN COMPLETE

---

## 1. Overview

### Purpose
Enable migration of legacy data (integer PKs) into IsoStack (UUID-based) while preserving foreign key relationships through a mapping table system.

### Key Design Principles
1. **Idempotency** - Re-running imports doesn't create duplicates
2. **Atomicity** - Imports succeed completely or fail completely (transactions)
3. **Traceability** - Every import logged, original data preserved
4. **Reversibility** - Failed imports can be rolled back
5. **Hierarchy-Aware** - Parent entities imported before children

---

## 2. Three-Table Architecture

### Core Pattern

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ImportJob   ‚îÇ  ‚Üê Tracks each import batch
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚îÇ has many
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ LegacyKeyMapping ‚îÇ  ‚Üê Maps legacy IDs to new UUIDs
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚îÇ references
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Entity Tables    ‚îÇ  ‚Üê Actual data (Club, Team, Venue, etc.)
‚îÇ (Club, Team...)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Table 1: ImportJob

**Purpose:** Track each import operation as a batch job

**Schema:**
```prisma
model ImportJob {
  id             String        @id @default(uuid())
  organizationId String        // Multi-tenant scoping
  seasonId       String?       // Optional module context (LMSPro)
  
  // Job metadata
  name           String        // "Derby Rangers Import 2025"
  description    String?
  status         ImportStatus  // PENDING ‚Üí VALIDATING ‚Üí IMPORTING ‚Üí COMPLETED
  entityType     ImportEntityType // CLUB, TEAM, VENUE, etc.
  sourceSystem   String?       // "Excel Export", "LeagueManager v3"
  
  // Statistics
  totalRecords   Int           @default(0)
  successCount   Int           @default(0)
  failureCount   Int           @default(0)
  
  // Error tracking
  errors         Json[]        // [{ row: 5, field: 'email', error: 'Invalid format' }]
  warnings       Json[]        // Non-fatal issues
  
  // Timestamps
  createdById    String
  startedAt      DateTime?
  completedAt    DateTime?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  
  // Relations
  organization   Organization  @relation(...)
  createdBy      User          @relation(...)
  mappings       LegacyKeyMapping[]
}
```

**Key Fields:**
- `status` - Tracks import lifecycle
- `errors` - JSON array of validation/import errors
- `entityType` - What's being imported (CLUB, TEAM, etc.)

---

### Table 2: LegacyKeyMapping

**Purpose:** Store bidirectional mapping between legacy IDs and new UUIDs

**Schema:**
```prisma
model LegacyKeyMapping {
  id             String        @id @default(uuid())
  importJobId    String        // Link to import batch
  organizationId String        // Multi-tenant scoping
  
  // The mapping
  entityType     ImportEntityType // CLUB, TEAM, etc.
  legacyId       String        // Original ID (stored as string: "1", "ABC123", "42")
  newId          String        // New UUID generated by IsoStack
  
  // Debugging aid
  legacyData     Json?         // Original row data (optional)
  
  createdAt      DateTime      @default(now())
  
  // Relations
  importJob      ImportJob     @relation(...)
  organization   Organization  @relation(...)
  
  // Unique constraint prevents duplicate mappings
  @@unique([organizationId, entityType, legacyId])
}
```

**Key Features:**
- **Unique constraint** prevents duplicate mappings
- **Composite index** for fast lookups (organizationId + entityType + legacyId)
- **Optional legacyData** stores original record for debugging

**Usage Example:**
```typescript
// When importing a team, look up parent club UUID
const clubMapping = await prisma.legacyKeyMapping.findUnique({
  where: {
    organizationId_entityType_legacyId: {
      organizationId: "org-123",
      entityType: "CLUB",
      legacyId: "42"  // Legacy club_id from CSV
    }
  }
});

// Use mapped UUID to create team
await prisma.lMSProTeam.create({
  data: {
    clubId: clubMapping.newId,  // ‚Üê New UUID, not legacy ID
    // ... other fields
  }
});
```

---

### Table 3: Entity Tables

**Purpose:** Store actual imported data (Clubs, Teams, Venues, etc.)

**Modified Schema:**
No changes required to existing entity tables (Club, Team, etc.). They continue using UUID primary keys.

**Why No Changes?**
- Mappings are stored separately in `LegacyKeyMapping`
- Entities remain clean, UUID-based
- No "legacy pollution" in core data models

---

## 3. Data Flow Diagrams

### 3.1 Import Flow (Happy Path)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. User uploads  ‚îÇ
‚îÇ    CSV/JSON      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. Parse file &  ‚îÇ
‚îÇ    validate data ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚îú‚îÄ Check required fields
         ‚îú‚îÄ Verify data types
         ‚îú‚îÄ Check FK references exist
         ‚îî‚îÄ Detect duplicates
         ‚îÇ
         ‚Üì
    Valid? ‚îÄ‚îÄNO‚îÄ‚îÄ‚Üí Return errors, stop
         ‚îÇ
        YES
         ‚îÇ
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 3. Create        ‚îÇ
‚îÇ    ImportJob     ‚îÇ
‚îÇ    (VALIDATING)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 4. For each row: ‚îÇ
‚îÇ                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ Start TX    ‚îÇ ‚îÇ
‚îÇ  ‚îÇ             ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Create    ‚îÇ ‚îÇ
‚îÇ  ‚îÇ   entity    ‚îÇ ‚îÇ
‚îÇ  ‚îÇ   (UUID)    ‚îÇ ‚îÇ
‚îÇ  ‚îÇ             ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Create    ‚îÇ ‚îÇ
‚îÇ  ‚îÇ   mapping   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ   (legacy‚Üí  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ    UUID)    ‚îÇ ‚îÇ
‚îÇ  ‚îÇ             ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Audit log ‚îÇ ‚îÇ
‚îÇ  ‚îÇ             ‚îÇ ‚îÇ
‚îÇ  ‚îÇ Commit TX   ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                  ‚îÇ
‚îÇ  If error:       ‚îÇ
‚îÇ  ‚Ä¢ Rollback TX   ‚îÇ
‚îÇ  ‚Ä¢ Log error     ‚îÇ
‚îÇ  ‚Ä¢ Continue      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 5. Update job    ‚îÇ
‚îÇ    ‚Ä¢ successCount‚îÇ
‚îÇ    ‚Ä¢ failureCount‚îÇ
‚îÇ    ‚Ä¢ errors[]    ‚îÇ
‚îÇ    ‚Ä¢ COMPLETED   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

### 3.2 Hierarchical Import (Clubs ‚Üí Teams)

```
Step 1: Import Clubs
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ CSV:                                 ‚îÇ
‚îÇ club_id, club_name                   ‚îÇ
‚îÇ 1,       "Derby Rangers"             ‚îÇ
‚îÇ 2,       "Nottingham United"         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ
                   ‚Üì
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ Create Club 1   ‚îÇ
         ‚îÇ (UUID: abc-123) ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
                  ‚Üì
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ LegacyKeyMapping:       ‚îÇ
         ‚îÇ legacyId: "1"           ‚îÇ
         ‚îÇ newId: "abc-123"        ‚îÇ
         ‚îÇ entityType: CLUB        ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Step 2: Import Teams (Using Mappings)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ CSV:                                 ‚îÇ
‚îÇ team_id, club_id, team_name          ‚îÇ
‚îÇ 101,     1,       "U9 Rangers"       ‚îÇ
‚îÇ 102,     2,       "U10 United"       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ
                   ‚Üì
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ Lookup club_id=1        ‚îÇ
         ‚îÇ ‚Üí Find mapping          ‚îÇ
         ‚îÇ ‚Üí newId = "abc-123"     ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
                  ‚Üì
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ Create Team     ‚îÇ
         ‚îÇ clubId: abc-123 ‚îÇ ‚Üê Uses mapped UUID
         ‚îÇ (UUID: xyz-789) ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
                  ‚Üì
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ LegacyKeyMapping:       ‚îÇ
         ‚îÇ legacyId: "101"         ‚îÇ
         ‚îÇ newId: "xyz-789"        ‚îÇ
         ‚îÇ entityType: TEAM        ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

### 3.3 Rollback Flow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ User triggers    ‚îÇ
‚îÇ rollback for     ‚îÇ
‚îÇ ImportJob #123   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. Fetch all     ‚îÇ
‚îÇ    mappings for  ‚îÇ
‚îÇ    job #123      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. Start TX      ‚îÇ
‚îÇ                  ‚îÇ
‚îÇ  For each map:   ‚îÇ
‚îÇ  ‚Ä¢ Delete entity ‚îÇ
‚îÇ    (Club/Team)   ‚îÇ
‚îÇ                  ‚îÇ
‚îÇ  Delete mappings ‚îÇ
‚îÇ                  ‚îÇ
‚îÇ  Update job:     ‚îÇ
‚îÇ  ‚Ä¢ ROLLED_BACK   ‚îÇ
‚îÇ                  ‚îÇ
‚îÇ  Audit log       ‚îÇ
‚îÇ                  ‚îÇ
‚îÇ Commit TX        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

### 3.4 Export Flow (Filterable)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ User selects:    ‚îÇ
‚îÇ ‚Ä¢ Entity type    ‚îÇ
‚îÇ ‚Ä¢ Season         ‚îÇ
‚îÇ ‚Ä¢ Club (opt)     ‚îÇ
‚îÇ ‚Ä¢ Age Group (opt)‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. Build query   ‚îÇ
‚îÇ    with filters  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. Fetch entities‚îÇ
‚îÇ    from DB       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 3. Transform to  ‚îÇ
‚îÇ    export format ‚îÇ
‚îÇ    (CSV/JSON)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 4. Include:      ‚îÇ
‚îÇ  ‚Ä¢ Current UUIDs ‚îÇ
‚îÇ  ‚Ä¢ Legacy IDs    ‚îÇ
‚îÇ    (if exist)    ‚îÇ
‚îÇ  ‚Ä¢ All data      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 5. Generate file ‚îÇ
‚îÇ    Download      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Export Filters:**
```typescript
interface ExportFilters {
  entityType: ImportEntityType;        // Required: What to export
  seasonId?: string;                   // Optional: Filter by season
  clubId?: string;                     // Optional: Filter by club
  ageGroupId?: string;                 // Optional: Filter by age group
  includeRelated?: boolean;            // Export related entities (e.g., teams with clubs)
  format?: 'CSV' | 'JSON';            // Output format
}
```

**Example: Export Teams for Specific Club**
```typescript
const filters: ExportFilters = {
  entityType: 'LMSPRO_TEAM',
  seasonId: 'season-123',
  clubId: 'club-456',        // Only teams for this club
  format: 'CSV',
};

const result = await exportData(filters);
// Returns CSV:
// team_id,team_name,club_id,club_name,age_group
// uuid-1,U9 Rangers,club-456,Derby Rangers,U9
// uuid-2,U10 Rangers,club-456,Derby Rangers,U10
```

**Example: Export All Clubs for Season**
```typescript
const filters: ExportFilters = {
  entityType: 'LMSPRO_CLUB',
  seasonId: 'season-123',
  includeRelated: true,      // Include team counts
  format: 'CSV',
};

const result = await exportData(filters);
// Returns CSV:
// club_id,club_name,short_name,team_count
// uuid-1,Derby Rangers,Rangers,12
// uuid-2,Nottingham United,United,8
```

---

## 4. Import Order & Dependencies

### Entity Hierarchy

```
Season (must exist first)
  ‚Üì
Clubs (no dependencies)
  ‚Üì
Teams (depends on Clubs)
  ‚Üì
Players (depends on Teams) ‚Üê Future
```

### Import Sequence
1. **Season**: Must exist (or create if missing)
2. **Clubs**: Independent, can import first
3. **Teams**: Requires clubs imported first (FK: clubId)
4. **Venues**: Independent (parallel with clubs)
5. **Referees**: Independent (parallel with clubs)

---

## 5. Validation Logic

### Pre-Import Validation

**Required Field Checks:**
```typescript
// Example for Clubs
const requiredFields = ['club_id', 'club_name'];
for (const field of requiredFields) {
  if (!row[field]) {
    errors.push({ row: i, field, error: 'Required field missing' });
  }
}
```

**Data Type Validation:**
```typescript
// Check numeric fields
if (row.club_id && isNaN(Number(row.club_id))) {
  errors.push({ row: i, field: 'club_id', error: 'Must be numeric' });
}

// Check email format
if (row.email && !isValidEmail(row.email)) {
  errors.push({ row: i, field: 'email', error: 'Invalid email format' });
}
```

**Foreign Key Existence:**
```typescript
// For teams, verify parent club exists in mappings
const clubMapping = await prisma.legacyKeyMapping.findUnique({
  where: {
    organizationId_entityType_legacyId: {
      organizationId: user.organizationId,
      entityType: 'CLUB',
      legacyId: row.club_id.toString()
    }
  }
});

if (!clubMapping) {
  errors.push({ 
    row: i, 
    field: 'club_id', 
    error: `Parent club with legacy ID ${row.club_id} not found` 
  });
}
```

**Duplicate Detection:**
```typescript
// Check for duplicate legacy IDs in CSV
const duplicates = data.filter((r, idx) => 
  idx !== i && r.club_id === row.club_id
);

if (duplicates.length > 0) {
  warnings.push({ 
    row: i, 
    field: 'club_id', 
    warning: 'Duplicate legacy ID in file' 
  });
}

// Check if already imported
const existing = await prisma.legacyKeyMapping.findUnique({
  where: {
    organizationId_entityType_legacyId: {
      organizationId: user.organizationId,
      entityType: 'CLUB',
      legacyId: row.club_id.toString()
    }
  }
});

if (existing) {
  warnings.push({ 
    row: i, 
    field: 'club_id', 
    warning: 'Already imported (will skip)' 
  });
}
```

---

## 6. Security Architecture

### Multi-Tenancy Enforcement

**Tenant Scoping Pattern:**
```typescript
// ALWAYS scope by organizationId
const importJob = await prisma.importJob.findUnique({
  where: { 
    id: input.importJobId,
    organizationId: ctx.session.user.organizationId  // ‚Üê CRITICAL
  }
});
```

**Why This Matters:**
- Prevents Organization A from importing into Organization B's data
- Prevents Organization A from viewing Organization B's import history
- Prevents cross-tenant data leaks via legacy mappings

### Permission Checks

**Role-Based Access:**
```typescript
// Only OWNER role can import
import.createJob: requireRole([Role.OWNER])

// Platform Admins (P1) have full access
if (isPlatformAdmin(session)) {
  // Can import into any organization
}
```

**Why P1 & C1 Only:**
- Import operations are high-risk (data integrity)
- Requires understanding of data model
- Potential for data corruption if done incorrectly
- ADMIN and MEMBER roles too low for this privilege

---

## 7. Performance Considerations

### Batch Processing

**Problem:** Importing 1000+ rows in single request = timeout

**Solution:** Chunked imports
```typescript
// Process in batches of 100
const BATCH_SIZE = 100;

for (let i = 0; i < data.length; i += BATCH_SIZE) {
  const batch = data.slice(i, i + BATCH_SIZE);
  
  await processBatch(batch);
  
  // Update progress
  await updateJobProgress(job.id, i + batch.length);
}
```

### Transaction Boundaries

**Per-Row Transactions** (Current Design):
```typescript
for (const row of data) {
  await prisma.$transaction(async (tx) => {
    // Create entity
    // Create mapping
    // Audit log
  });
}
```

**Why Not One Big Transaction?**
- ‚úÖ Failed rows don't break entire import
- ‚úÖ Partial success possible
- ‚úÖ Better error isolation
- ‚ùå Slower (more DB round-trips)

**Future Optimization:**
- Batch 10-50 rows per transaction
- Trade-off between atomicity and speed

---

## 8. Error Handling Strategy

### Error Categories

**1. Validation Errors** (Pre-Import)
- Missing required fields
- Invalid data types
- FK references don't exist
- **Action:** Stop import, return errors

**2. Import Errors** (During Import)
- Database constraint violations
- Unique key conflicts
- Transaction failures
- **Action:** Skip row, log error, continue

**3. System Errors**
- Database connection lost
- Timeout
- Out of memory
- **Action:** Mark job as FAILED, preserve partial progress

### Error Storage

```typescript
// Errors stored in ImportJob.errors (JSON array)
{
  row: 5,
  field: 'email',
  legacyId: '42',
  recordData: { club_id: 42, club_name: 'Rangers' },
  error: 'Email address invalid',
  timestamp: '2026-01-05T10:30:00Z'
}
```

---

## 9. Audit Trail

### What Gets Logged

**1. Import Job Lifecycle:**
```typescript
await auditLog.create({
  action: 'IMPORT_JOB_CREATED',
  entityType: 'ImportJob',
  entityId: job.id,
  metadata: { jobName, entityType }
});

await auditLog.create({
  action: 'IMPORT_JOB_COMPLETED',
  entityType: 'ImportJob',
  entityId: job.id,
  metadata: { successCount: 42, failureCount: 3 }
});
```

**2. Entity Creation:**
```typescript
await auditLog.create({
  action: 'CLUB_IMPORTED',
  entityType: 'LMSProClub',
  entityId: newClub.id,
  metadata: { 
    legacyId: '42',
    importJobId: job.id,
    clubName: 'Derby Rangers'
  }
});
```

**3. Rollbacks:**
```typescript
await auditLog.create({
  action: 'IMPORT_ROLLED_BACK',
  entityType: 'ImportJob',
  entityId: job.id,
  metadata: { deletedCount: 42 }
});
```

---

## 10. Module Integration Pattern

### Entity Registry

Modules register their importable entities via a registry pattern, keeping the core import engine clean and extensible.

**Core Import Registry:**
```typescript
// src/lib/import/registry.ts
export interface ImportHandler<T = any> {
  validate: (data: any[], context: ImportContext) => Promise<ValidationResult>;
  import: (data: any[], context: ImportContext) => Promise<ImportResult>;
  rollback: (mappings: LegacyKeyMapping[], context: ImportContext) => Promise<void>;
  export?: (filters: ExportFilters, context: ImportContext) => Promise<any[]>;
}

type ImportContext = {
  organizationId: string;
  seasonId?: string;
  userId: string;
  tx: PrismaTransaction;
};

const importRegistry = new Map<ImportEntityType, ImportHandler>();

export function registerImportHandler(entityType: ImportEntityType, handler: ImportHandler) {
  importRegistry.set(entityType, handler);
}

export function getImportHandler(entityType: ImportEntityType): ImportHandler {
  const handler = importRegistry.get(entityType);
  if (!handler) {
    throw new Error(`No import handler registered for ${entityType}`);
  }
  return handler;
}
```

**LMSPro Module Registration:**
```typescript
// src/modules/lmspro/import/index.ts
import { registerImportHandler, ImportEntityType } from '@/lib/import/registry';
import { clubImportHandler } from './handlers/club';
import { teamImportHandler } from './handlers/team';

// Register handlers on module initialization
registerImportHandler(ImportEntityType.LMSPRO_CLUB, clubImportHandler);
registerImportHandler(ImportEntityType.LMSPRO_TEAM, teamImportHandler);
```

**Example Handler Implementation:**
```typescript
// src/modules/lmspro/import/handlers/club.ts
import { ImportHandler } from '@/lib/import/registry';
import { z } from 'zod';

const clubSchema = z.object({
  club_id: z.string(),
  club_name: z.string().min(1),
  short_name: z.string().optional(),
  fa_number: z.string().optional(),
});

export const clubImportHandler: ImportHandler = {
  async validate(data, context) {
    const errors: any[] = [];
    const warnings: any[] = [];

    for (let i = 0; i < data.length; i++) {
      const row = data[i];
      
      // Zod validation
      const result = clubSchema.safeParse(row);
      if (!result.success) {
        errors.push({ row: i + 1, errors: result.error.errors });
        continue;
      }

      // Check for duplicates in existing data
      const existing = await context.tx.legacyKeyMapping.findUnique({
        where: {
          organizationId_entityType_legacyId: {
            organizationId: context.organizationId,
            entityType: 'LMSPRO_CLUB',
            legacyId: row.club_id,
          },
        },
      });

      if (existing) {
        warnings.push({
          row: i + 1,
          message: `Club with legacy ID ${row.club_id} already imported`,
        });
      }
    }

    return { valid: errors.length === 0, errors, warnings };
  },

  async import(data, context) {
    const results = [];

    for (const row of data) {
      try {
        // Create club
        const club = await context.tx.lMSProClub.create({
          data: {
            name: row.club_name,
            shortName: row.short_name,
            faNumber: row.fa_number,
            organizationId: context.organizationId,
            seasonId: context.seasonId!,
          },
        });

        // Create mapping
        await context.tx.legacyKeyMapping.create({
          data: {
            importJobId: context.importJobId,
            organizationId: context.organizationId,
            entityType: 'LMSPRO_CLUB',
            legacyId: row.club_id,
            newId: club.id,
            legacyData: row,
          },
        });

        results.push({ success: true, legacyId: row.club_id, newId: club.id });
      } catch (error) {
        results.push({ 
          success: false, 
          legacyId: row.club_id, 
          error: error instanceof Error ? error.message : 'Unknown error' 
        });
      }
    }

    return results;
  },

  async rollback(mappings, context) {
    const clubIds = mappings.map(m => m.newId);
    await context.tx.lMSProClub.deleteMany({
      where: { id: { in: clubIds } },
    });
  },

  async export(filters, context) {
    const clubs = await context.tx.lMSProClub.findMany({
      where: {
        organizationId: context.organizationId,
        seasonId: filters.seasonId || context.seasonId,
        ...(filters.clubId && { id: filters.clubId }),
      },
      include: {
        _count: { select: { teams: true } },
      },
    });

    return clubs.map(club => ({
      club_id: club.id,
      club_name: club.name,
      short_name: club.shortName,
      fa_number: club.faNumber,
      team_count: club._count.teams,
    }));
  },
};
```

### Why This Pattern?

**‚úÖ Separation of Concerns**
- Core import engine handles job management, transactions, audit logs
- Modules handle entity-specific validation and data transformation
- No module-specific code in core

**‚úÖ Type Safety**
- Each handler is strongly typed
- Zod schemas provide runtime validation
- TypeScript ensures handler interface compliance

**‚úÖ Testability**
- Handlers can be unit tested independently
- Mock context for isolated testing
- Integration tests use real handlers

**‚úÖ Extensibility**
- New modules register handlers on initialization
- No changes to core import engine
- Modules can add custom validation logic

---

## 11. Integration Points

### With Core Platform

**Authentication:**
```typescript
// Uses NextAuth session
const session = await auth();
const userId = session.user.id;
const organizationId = session.user.organizationId;
```

**Permissions:**
```typescript
// Uses core permission helpers
import { requireRole } from '@/server/permissions';

importRouter: router({
  createJob: requireRole([Role.OWNER])
    .mutation(...)
});
```

**Audit Logging:**
```typescript
// Uses core AuditLog model
await prisma.auditLog.create({
  data: { /* ... */ }
});
```

### With Modules

**LMSPro Example:**
```typescript
// Import LMSPro clubs
if (job.entityType === 'CLUB' && job.seasonId) {
  const newClub = await tx.lMSProClub.create({
    data: {
      organizationId: job.organizationId,
      seasonId: job.seasonId,  // ‚Üê Module context
      // ... club data
    }
  });
}
```

**Generic Pattern:**
- Import system is module-agnostic
- Modules provide entity-specific import logic
- Mapping table works for any entity type

---

## 11. Future Architecture Enhancements

### Phase 2: Export Functionality

**Export Flow:**
```
1. Select entity type (Clubs, Teams)
2. Generate CSV with:
   - Current UUID IDs
   - Legacy IDs (from mappings)
   - All entity data
3. Download file
```

### Phase 3: Scheduled Imports

**Cron-Based Imports:**
- Weekly imports from Google Sheets
- Daily sync from external API
- Requires: Job queue system (BullMQ, Inngest)

### Phase 4: Real-Time Sync

**Webhook-Based:**
- External system pushes changes
- Webhook receives, validates, imports
- Updates existing records (upsert pattern)

---

## 12. Deployment Architecture

### Database Changes

**Migration Strategy:**
```sql
-- Add new tables (additive only)
CREATE TABLE import_jobs (...);
CREATE TABLE legacy_key_mappings (...);

-- Add relations to existing tables
ALTER TABLE organizations ADD COLUMN ...;
ALTER TABLE users ADD COLUMN ...;
```

**No Downtime:**
- Schema changes are additive (new tables)
- No modifications to existing tables
- Existing functionality unaffected

### Rollout Plan

1. **Dev:** Deploy schema + code
2. **Staging:** Test with real data
3. **Production:** Deploy during low-traffic window
4. **Monitor:** Watch error logs, database performance

---

## 13. Design Decisions & Rationale

### Why Three Tables (Not Two)?

**Alternative:** Store legacy IDs directly in entity tables
```prisma
model Club {
  legacyId String?  // ‚ùå Pollutes entity model
}
```

**Why Rejected:**
- ‚ùå Pollutes core data models
- ‚ùå Not all entities have legacy IDs
- ‚ùå Hard to track import batches
- ‚ùå Can't rollback easily

**Chosen Design:**
- ‚úÖ Separation of concerns (mapping vs data)
- ‚úÖ Clean entity models
- ‚úÖ Easy to delete all import metadata
- ‚úÖ Tracks import job context

### Why Store legacyData (JSON)?

**Purpose:** Debugging aid
- Compare original vs imported data
- Diagnose why import failed
- Re-import with corrections

**Trade-off:**
- ‚úÖ Invaluable for debugging
- ‚úÖ Disk space is cheap
- ‚ùå Increases storage (marginal)

---

## 14. Compliance & GDPR

### Data Retention

**Import Jobs:**
- Retain for 90 days (configurable)
- Auto-delete old jobs (cron task)

**Mappings:**
- Retain indefinitely (needed for data integrity)
- Delete only when organization deleted

**Legacy Data (JSON):**
- May contain PII (names, emails)
- Option to purge after successful import
- GDPR right-to-erasure support

---

## Summary

The Import/Export system uses a three-table architecture (ImportJob, LegacyKeyMapping, Entities) to enable safe, traceable, and reversible data migration from legacy systems. Key design choices prioritize data integrity, multi-tenancy, and auditability.

**Next Steps:**
- Review `implementation-plan.md` for build sequence
- Review `testing.md` for validation scenarios
