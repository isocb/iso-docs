# Import/Export System - Architecture

**Document Version:** 2.0  
**Last Updated:** 2026-01-06  
**Status:** ✅ IMPLEMENTED

---

## Implementation Status

**Phases Completed:** 0-7 (All phases complete)  
**Branch:** `dev`  
**Migration:** `20260106184110_add_import_export_system`  
**Test Coverage:** 45 tests passing (parser, registry, handler)

### Recent Implementation (2026-01-06)

- ✅ **Phase 0-1:** Setup & Schema (ImportJob, LegacyKeyMapping models)
- ✅ **Phase 2:** tRPC Router with 9 endpoints (createJob, listJobs, getJob, updateJobStatus, deleteJob, getMapping, getJobMappings, rollback, export)
- ✅ **Phase 3-4:** Validation & Execution engine with LMSPro club handler
- ✅ **Phase 5:** Frontend Import Wizard (multi-step Stepper UI) + Jobs List page
- ✅ **Phase 7:** Export functionality (CSV/JSON with filtering)
- ✅ **Phase 6:** Comprehensive test suite (29 unit tests + 16 handler tests)

**Key Features Working:**
- CSV parsing with Papa Parse
- Handler registry for extensibility  
- Import validation with error/warning reporting
- Transaction-based import execution
- Rollback capability for failed imports
- Legacy ID mapping (bidirectional)
- Export with legacy ID preservation
- Multi-tenant data isolation
- Audit logging

**Next Steps:**
- Add navigation links to Import/Export pages
- Deploy to techtest environment

---

## 1. Overview

### Purpose
Enable migration of legacy data (integer PKs) into IsoStack (UUID-based) while preserving foreign key relationships through a mapping table system.

### Key Design Principles
1. **Idempotency** - Re-running imports doesn't create duplicates
2. **Atomicity** - Imports succeed completely or fail completely (transactions)
3. **Traceability** - Every import logged, original data preserved
4. **Reversibility** - Failed imports can be rolled back
5. **Hierarchy-Aware** - Parent entities imported before children

---

## 2. Three-Table Architecture

### Core Pattern

```
┌─────────────┐
│ ImportJob   │  ← Tracks each import batch
└──────┬──────┘
       │
       │ has many
       ↓
┌──────────────────┐
│ LegacyKeyMapping │  ← Maps legacy IDs to new UUIDs
└────────┬─────────┘
         │
         │ references
         ↓
┌──────────────────┐
│ Entity Tables    │  ← Actual data (Club, Team, Venue, etc.)
│ (Club, Team...)  │
└──────────────────┘
```

### Table 1: ImportJob

**Purpose:** Track each import operation as a batch job

**Schema:**
```prisma
model ImportJob {
  id             String        @id @default(uuid())
  organizationId String        // Multi-tenant scoping
  seasonId       String?       // Optional module context (LMSPro)
  
  // Job metadata
  name           String        // "Derby Rangers Import 2025"
  description    String?
  status         ImportStatus  // PENDING → VALIDATING → IMPORTING → COMPLETED
  entityType     ImportEntityType // CLUB, TEAM, VENUE, etc.
  sourceSystem   String?       // "Excel Export", "LeagueManager v3"
  
  // Statistics
  totalRecords   Int           @default(0)
  successCount   Int           @default(0)
  failureCount   Int           @default(0)
  
  // Error tracking
  errors         Json[]        // [{ row: 5, field: 'email', error: 'Invalid format' }]
  warnings       Json[]        // Non-fatal issues
  
  // Timestamps
  createdById    String
  startedAt      DateTime?
  completedAt    DateTime?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  
  // Relations
  organization   Organization  @relation(...)
  createdBy      User          @relation(...)
  mappings       LegacyKeyMapping[]
}
```

**Key Fields:**
- `status` - Tracks import lifecycle
- `errors` - JSON array of validation/import errors
- `entityType` - What's being imported (CLUB, TEAM, etc.)

---

### Table 2: LegacyKeyMapping

**Purpose:** Store bidirectional mapping between legacy IDs and new UUIDs

**Schema:**
```prisma
model LegacyKeyMapping {
  id             String        @id @default(uuid())
  importJobId    String        // Link to import batch
  organizationId String        // Multi-tenant scoping
  
  // The mapping
  entityType     ImportEntityType // CLUB, TEAM, etc.
  legacyId       String        // Original ID (stored as string: "1", "ABC123", "42")
  newId          String        // New UUID generated by IsoStack
  
  // Debugging aid
  legacyData     Json?         // Original row data (optional)
  
  createdAt      DateTime      @default(now())
  
  // Relations
  importJob      ImportJob     @relation(...)
  organization   Organization  @relation(...)
  
  // Unique constraint prevents duplicate mappings
  @@unique([organizationId, entityType, legacyId])
}
```

**Key Features:**
- **Unique constraint** prevents duplicate mappings
- **Composite index** for fast lookups (organizationId + entityType + legacyId)
- **Optional legacyData** stores original record for debugging

**Usage Example:**
```typescript
// When importing a team, look up parent club UUID
const clubMapping = await prisma.legacyKeyMapping.findUnique({
  where: {
    organizationId_entityType_legacyId: {
      organizationId: "org-123",
      entityType: "CLUB",
      legacyId: "42"  // Legacy club_id from CSV
    }
  }
});

// Use mapped UUID to create team
await prisma.lMSProTeam.create({
  data: {
    clubId: clubMapping.newId,  // ← New UUID, not legacy ID
    // ... other fields
  }
});
```

---

### Table 3: Entity Tables

**Purpose:** Store actual imported data (Clubs, Teams, Venues, etc.)

**Modified Schema:**
No changes required to existing entity tables (Club, Team, etc.). They continue using UUID primary keys.

**Why No Changes?**
- Mappings are stored separately in `LegacyKeyMapping`
- Entities remain clean, UUID-based
- No "legacy pollution" in core data models

---

## 3. Data Flow Diagrams

### 3.1 Import Flow (Happy Path)

```
┌──────────────────┐
│ 1. User uploads  │
│    CSV/JSON      │
└────────┬─────────┘
         │
         ↓
┌──────────────────┐
│ 2. Parse file &  │
│    validate data │
└────────┬─────────┘
         │
         ├─ Check required fields
         ├─ Verify data types
         ├─ Check FK references exist
         └─ Detect duplicates
         │
         ↓
    Valid? ──NO──→ Return errors, stop
         │
        YES
         │
         ↓
┌──────────────────┐
│ 3. Create        │
│    ImportJob     │
│    (VALIDATING)  │
└────────┬─────────┘
         │
         ↓
┌──────────────────┐
│ 4. For each row: │
│                  │
│  ┌─────────────┐ │
│  │ Start TX    │ │
│  │             │ │
│  │ • Create    │ │
│  │   entity    │ │
│  │   (UUID)    │ │
│  │             │ │
│  │ • Create    │ │
│  │   mapping   │ │
│  │   (legacy→  │ │
│  │    UUID)    │ │
│  │             │ │
│  │ • Audit log │ │
│  │             │ │
│  │ Commit TX   │ │
│  └─────────────┘ │
│                  │
│  If error:       │
│  • Rollback TX   │
│  • Log error     │
│  • Continue      │
└────────┬─────────┘
         │
         ↓
┌──────────────────┐
│ 5. Update job    │
│    • successCount│
│    • failureCount│
│    • errors[]    │
│    • COMPLETED   │
└──────────────────┘
```

---

### 3.2 Hierarchical Import (Clubs → Teams)

```
Step 1: Import Clubs
┌──────────────────────────────────────┐
│ CSV:                                 │
│ club_id, club_name                   │
│ 1,       "Derby Rangers"             │
│ 2,       "Nottingham United"         │
└──────────────────┬───────────────────┘
                   │
                   ↓
         ┌─────────────────┐
         │ Create Club 1   │
         │ (UUID: abc-123) │
         └────────┬────────┘
                  │
                  ↓
         ┌─────────────────────────┐
         │ LegacyKeyMapping:       │
         │ legacyId: "1"           │
         │ newId: "abc-123"        │
         │ entityType: CLUB        │
         └─────────────────────────┘

Step 2: Import Teams (Using Mappings)
┌──────────────────────────────────────┐
│ CSV:                                 │
│ team_id, club_id, team_name          │
│ 101,     1,       "U9 Rangers"       │
│ 102,     2,       "U10 United"       │
└──────────────────┬───────────────────┘
                   │
                   ↓
         ┌─────────────────────────┐
         │ Lookup club_id=1        │
         │ → Find mapping          │
         │ → newId = "abc-123"     │
         └────────┬────────────────┘
                  │
                  ↓
         ┌─────────────────┐
         │ Create Team     │
         │ clubId: abc-123 │ ← Uses mapped UUID
         │ (UUID: xyz-789) │
         └────────┬────────┘
                  │
                  ↓
         ┌─────────────────────────┐
         │ LegacyKeyMapping:       │
         │ legacyId: "101"         │
         │ newId: "xyz-789"        │
         │ entityType: TEAM        │
         └─────────────────────────┘
```

---

### 3.3 Rollback Flow

```
┌──────────────────┐
│ User triggers    │
│ rollback for     │
│ ImportJob #123   │
└────────┬─────────┘
         │
         ↓
┌──────────────────┐
│ 1. Fetch all     │
│    mappings for  │
│    job #123      │
└────────┬─────────┘
         │
         ↓
┌──────────────────┐
│ 2. Start TX      │
│                  │
│  For each map:   │
│  • Delete entity │
│    (Club/Team)   │
│                  │
│  Delete mappings │
│                  │
│  Update job:     │
│  • ROLLED_BACK   │
│                  │
│  Audit log       │
│                  │
│ Commit TX        │
└──────────────────┘
```

---

### 3.4 Export Flow (Filterable)

```
┌──────────────────┐
│ User selects:    │
│ • Entity type    │
│ • Season         │
│ • Club (opt)     │
│ • Age Group (opt)│
└────────┬─────────┘
         │
         ↓
┌──────────────────┐
│ 1. Build query   │
│    with filters  │
└────────┬─────────┘
         │
         ↓
┌──────────────────┐
│ 2. Fetch entities│
│    from DB       │
└────────┬─────────┘
         │
         ↓
┌──────────────────┐
│ 3. Transform to  │
│    export format │
│    (CSV/JSON)    │
└────────┬─────────┘
         │
         ↓
┌──────────────────┐
│ 4. Include:      │
│  • Current UUIDs │
│  • Legacy IDs    │
│    (if exist)    │
│  • All data      │
└────────┬─────────┘
         │
         ↓
┌──────────────────┐
│ 5. Generate file │
│    Download      │
└──────────────────┘
```

**Export Filters:**
```typescript
interface ExportFilters {
  entityType: ImportEntityType;        // Required: What to export
  seasonId?: string;                   // Optional: Filter by season
  clubId?: string;                     // Optional: Filter by club
  ageGroupId?: string;                 // Optional: Filter by age group
  includeRelated?: boolean;            // Export related entities (e.g., teams with clubs)
  format?: 'CSV' | 'JSON';            // Output format
}
```

**Example: Export Teams for Specific Club**
```typescript
const filters: ExportFilters = {
  entityType: 'LMSPRO_TEAM',
  seasonId: 'season-123',
  clubId: 'club-456',        // Only teams for this club
  format: 'CSV',
};

const result = await exportData(filters);
// Returns CSV:
// team_id,team_name,club_id,club_name,age_group
// uuid-1,U9 Rangers,club-456,Derby Rangers,U9
// uuid-2,U10 Rangers,club-456,Derby Rangers,U10
```

**Example: Export All Clubs for Season**
```typescript
const filters: ExportFilters = {
  entityType: 'LMSPRO_CLUB',
  seasonId: 'season-123',
  includeRelated: true,      // Include team counts
  format: 'CSV',
};

const result = await exportData(filters);
// Returns CSV:
// club_id,club_name,short_name,team_count
// uuid-1,Derby Rangers,Rangers,12
// uuid-2,Nottingham United,United,8
```

---

## 4. Import Order & Dependencies

### Entity Hierarchy

```
Season (must exist first)
  ↓
Clubs (no dependencies)
  ↓
Teams (depends on Clubs)
  ↓
Players (depends on Teams) ← Future
```

### Import Sequence
1. **Season**: Must exist (or create if missing)
2. **Clubs**: Independent, can import first
3. **Teams**: Requires clubs imported first (FK: clubId)
4. **Venues**: Independent (parallel with clubs)
5. **Referees**: Independent (parallel with clubs)

---

## 5. Validation Logic

### Pre-Import Validation

**Required Field Checks:**
```typescript
// Example for Clubs
const requiredFields = ['club_id', 'club_name'];
for (const field of requiredFields) {
  if (!row[field]) {
    errors.push({ row: i, field, error: 'Required field missing' });
  }
}
```

**Data Type Validation:**
```typescript
// Check numeric fields
if (row.club_id && isNaN(Number(row.club_id))) {
  errors.push({ row: i, field: 'club_id', error: 'Must be numeric' });
}

// Check email format
if (row.email && !isValidEmail(row.email)) {
  errors.push({ row: i, field: 'email', error: 'Invalid email format' });
}
```

**Foreign Key Existence:**
```typescript
// For teams, verify parent club exists in mappings
const clubMapping = await prisma.legacyKeyMapping.findUnique({
  where: {
    organizationId_entityType_legacyId: {
      organizationId: user.organizationId,
      entityType: 'CLUB',
      legacyId: row.club_id.toString()
    }
  }
});

if (!clubMapping) {
  errors.push({ 
    row: i, 
    field: 'club_id', 
    error: `Parent club with legacy ID ${row.club_id} not found` 
  });
}
```

**Duplicate Detection:**
```typescript
// Check for duplicate legacy IDs in CSV
const duplicates = data.filter((r, idx) => 
  idx !== i && r.club_id === row.club_id
);

if (duplicates.length > 0) {
  warnings.push({ 
    row: i, 
    field: 'club_id', 
    warning: 'Duplicate legacy ID in file' 
  });
}

// Check if already imported
const existing = await prisma.legacyKeyMapping.findUnique({
  where: {
    organizationId_entityType_legacyId: {
      organizationId: user.organizationId,
      entityType: 'CLUB',
      legacyId: row.club_id.toString()
    }
  }
});

if (existing) {
  warnings.push({ 
    row: i, 
    field: 'club_id', 
    warning: 'Already imported (will skip)' 
  });
}
```

---

## 6. Security Architecture

### Multi-Tenancy Enforcement

**Tenant Scoping Pattern:**
```typescript
// ALWAYS scope by organizationId
const importJob = await prisma.importJob.findUnique({
  where: { 
    id: input.importJobId,
    organizationId: ctx.session.user.organizationId  // ← CRITICAL
  }
});
```

**Why This Matters:**
- Prevents Organization A from importing into Organization B's data
- Prevents Organization A from viewing Organization B's import history
- Prevents cross-tenant data leaks via legacy mappings

### Permission Checks

**Role-Based Access:**
```typescript
// Only OWNER role can import
import.createJob: requireRole([Role.OWNER])

// Platform Admins (P1) have full access
if (isPlatformAdmin(session)) {
  // Can import into any organization
}
```

**Why P1 & C1 Only:**
- Import operations are high-risk (data integrity)
- Requires understanding of data model
- Potential for data corruption if done incorrectly
- ADMIN and MEMBER roles too low for this privilege

---

## 7. Performance Considerations

### Batch Processing

**Problem:** Importing 1000+ rows in single request = timeout

**Solution:** Chunked imports
```typescript
// Process in batches of 100
const BATCH_SIZE = 100;

for (let i = 0; i < data.length; i += BATCH_SIZE) {
  const batch = data.slice(i, i + BATCH_SIZE);
  
  await processBatch(batch);
  
  // Update progress
  await updateJobProgress(job.id, i + batch.length);
}
```

### Transaction Boundaries

**Per-Row Transactions** (Current Design):
```typescript
for (const row of data) {
  await prisma.$transaction(async (tx) => {
    // Create entity
    // Create mapping
    // Audit log
  });
}
```

**Why Not One Big Transaction?**
- ✅ Failed rows don't break entire import
- ✅ Partial success possible
- ✅ Better error isolation
- ❌ Slower (more DB round-trips)

**Future Optimization:**
- Batch 10-50 rows per transaction
- Trade-off between atomicity and speed

---

## 8. Error Handling Strategy

### Error Categories

**1. Validation Errors** (Pre-Import)
- Missing required fields
- Invalid data types
- FK references don't exist
- **Action:** Stop import, return errors

**2. Import Errors** (During Import)
- Database constraint violations
- Unique key conflicts
- Transaction failures
- **Action:** Skip row, log error, continue

**3. System Errors**
- Database connection lost
- Timeout
- Out of memory
- **Action:** Mark job as FAILED, preserve partial progress

### Error Storage

```typescript
// Errors stored in ImportJob.errors (JSON array)
{
  row: 5,
  field: 'email',
  legacyId: '42',
  recordData: { club_id: 42, club_name: 'Rangers' },
  error: 'Email address invalid',
  timestamp: '2026-01-05T10:30:00Z'
}
```

---

## 9. Audit Trail

### What Gets Logged

**1. Import Job Lifecycle:**
```typescript
await auditLog.create({
  action: 'IMPORT_JOB_CREATED',
  entityType: 'ImportJob',
  entityId: job.id,
  metadata: { jobName, entityType }
});

await auditLog.create({
  action: 'IMPORT_JOB_COMPLETED',
  entityType: 'ImportJob',
  entityId: job.id,
  metadata: { successCount: 42, failureCount: 3 }
});
```

**2. Entity Creation:**
```typescript
await auditLog.create({
  action: 'CLUB_IMPORTED',
  entityType: 'LMSProClub',
  entityId: newClub.id,
  metadata: { 
    legacyId: '42',
    importJobId: job.id,
    clubName: 'Derby Rangers'
  }
});
```

**3. Rollbacks:**
```typescript
await auditLog.create({
  action: 'IMPORT_ROLLED_BACK',
  entityType: 'ImportJob',
  entityId: job.id,
  metadata: { deletedCount: 42 }
});
```

---

## 10. Module Integration Pattern

### Entity Registry

Modules register their importable entities via a registry pattern, keeping the core import engine clean and extensible.

**Core Import Registry:**
```typescript
// src/lib/import/registry.ts
export interface ImportHandler<T = any> {
  validate: (data: any[], context: ImportContext) => Promise<ValidationResult>;
  import: (data: any[], context: ImportContext) => Promise<ImportResult>;
  rollback: (mappings: LegacyKeyMapping[], context: ImportContext) => Promise<void>;
  export?: (filters: ExportFilters, context: ImportContext) => Promise<any[]>;
}

type ImportContext = {
  organizationId: string;
  seasonId?: string;
  userId: string;
  tx: PrismaTransaction;
};

const importRegistry = new Map<ImportEntityType, ImportHandler>();

export function registerImportHandler(entityType: ImportEntityType, handler: ImportHandler) {
  importRegistry.set(entityType, handler);
}

export function getImportHandler(entityType: ImportEntityType): ImportHandler {
  const handler = importRegistry.get(entityType);
  if (!handler) {
    throw new Error(`No import handler registered for ${entityType}`);
  }
  return handler;
}
```

**LMSPro Module Registration:**
```typescript
// src/modules/lmspro/import/index.ts
import { registerImportHandler, ImportEntityType } from '@/lib/import/registry';
import { clubImportHandler } from './handlers/club';
import { teamImportHandler } from './handlers/team';

// Register handlers on module initialization
registerImportHandler(ImportEntityType.LMSPRO_CLUB, clubImportHandler);
registerImportHandler(ImportEntityType.LMSPRO_TEAM, teamImportHandler);
```

**Example Handler Implementation:**
```typescript
// src/modules/lmspro/import/handlers/club.ts
import { ImportHandler } from '@/lib/import/registry';
import { z } from 'zod';

const clubSchema = z.object({
  club_id: z.string(),
  club_name: z.string().min(1),
  short_name: z.string().optional(),
  fa_number: z.string().optional(),
});

export const clubImportHandler: ImportHandler = {
  async validate(data, context) {
    const errors: any[] = [];
    const warnings: any[] = [];

    for (let i = 0; i < data.length; i++) {
      const row = data[i];
      
      // Zod validation
      const result = clubSchema.safeParse(row);
      if (!result.success) {
        errors.push({ row: i + 1, errors: result.error.errors });
        continue;
      }

      // Check for duplicates in existing data
      const existing = await context.tx.legacyKeyMapping.findUnique({
        where: {
          organizationId_entityType_legacyId: {
            organizationId: context.organizationId,
            entityType: 'LMSPRO_CLUB',
            legacyId: row.club_id,
          },
        },
      });

      if (existing) {
        warnings.push({
          row: i + 1,
          message: `Club with legacy ID ${row.club_id} already imported`,
        });
      }
    }

    return { valid: errors.length === 0, errors, warnings };
  },

  async import(data, context) {
    const results = [];

    for (const row of data) {
      try {
        // Create club
        const club = await context.tx.lMSProClub.create({
          data: {
            name: row.club_name,
            shortName: row.short_name,
            faNumber: row.fa_number,
            organizationId: context.organizationId,
            seasonId: context.seasonId!,
          },
        });

        // Create mapping
        await context.tx.legacyKeyMapping.create({
          data: {
            importJobId: context.importJobId,
            organizationId: context.organizationId,
            entityType: 'LMSPRO_CLUB',
            legacyId: row.club_id,
            newId: club.id,
            legacyData: row,
          },
        });

        results.push({ success: true, legacyId: row.club_id, newId: club.id });
      } catch (error) {
        results.push({ 
          success: false, 
          legacyId: row.club_id, 
          error: error instanceof Error ? error.message : 'Unknown error' 
        });
      }
    }

    return results;
  },

  async rollback(mappings, context) {
    const clubIds = mappings.map(m => m.newId);
    await context.tx.lMSProClub.deleteMany({
      where: { id: { in: clubIds } },
    });
  },

  async export(filters, context) {
    const clubs = await context.tx.lMSProClub.findMany({
      where: {
        organizationId: context.organizationId,
        seasonId: filters.seasonId || context.seasonId,
        ...(filters.clubId && { id: filters.clubId }),
      },
      include: {
        _count: { select: { teams: true } },
      },
    });

    return clubs.map(club => ({
      club_id: club.id,
      club_name: club.name,
      short_name: club.shortName,
      fa_number: club.faNumber,
      team_count: club._count.teams,
    }));
  },
};
```

### Why This Pattern?

**✅ Separation of Concerns**
- Core import engine handles job management, transactions, audit logs
- Modules handle entity-specific validation and data transformation
- No module-specific code in core

**✅ Type Safety**
- Each handler is strongly typed
- Zod schemas provide runtime validation
- TypeScript ensures handler interface compliance

**✅ Testability**
- Handlers can be unit tested independently
- Mock context for isolated testing
- Integration tests use real handlers

**✅ Extensibility**
- New modules register handlers on initialization
- No changes to core import engine
- Modules can add custom validation logic

---

## 11. Integration Points

### With Core Platform

**Authentication:**
```typescript
// Uses NextAuth session
const session = await auth();
const userId = session.user.id;
const organizationId = session.user.organizationId;
```

**Permissions:**
```typescript
// Uses core permission helpers
import { requireRole } from '@/server/permissions';

importRouter: router({
  createJob: requireRole([Role.OWNER])
    .mutation(...)
});
```

**Audit Logging:**
```typescript
// Uses core AuditLog model
await prisma.auditLog.create({
  data: { /* ... */ }
});
```

### With Modules

**LMSPro Example:**
```typescript
// Import LMSPro clubs
if (job.entityType === 'CLUB' && job.seasonId) {
  const newClub = await tx.lMSProClub.create({
    data: {
      organizationId: job.organizationId,
      seasonId: job.seasonId,  // ← Module context
      // ... club data
    }
  });
}
```

**Generic Pattern:**
- Import system is module-agnostic
- Modules provide entity-specific import logic
- Mapping table works for any entity type

---

## 11. Future Architecture Enhancements

### Phase 2: Export Functionality

**Export Flow:**
```
1. Select entity type (Clubs, Teams)
2. Generate CSV with:
   - Current UUID IDs
   - Legacy IDs (from mappings)
   - All entity data
3. Download file
```

### Phase 3: Scheduled Imports

**Cron-Based Imports:**
- Weekly imports from Google Sheets
- Daily sync from external API
- Requires: Job queue system (BullMQ, Inngest)

### Phase 4: Real-Time Sync

**Webhook-Based:**
- External system pushes changes
- Webhook receives, validates, imports
- Updates existing records (upsert pattern)

---

## 12. Deployment Architecture

### Database Changes

**Migration Strategy:**
```sql
-- Add new tables (additive only)
CREATE TABLE import_jobs (...);
CREATE TABLE legacy_key_mappings (...);

-- Add relations to existing tables
ALTER TABLE organizations ADD COLUMN ...;
ALTER TABLE users ADD COLUMN ...;
```

**No Downtime:**
- Schema changes are additive (new tables)
- No modifications to existing tables
- Existing functionality unaffected

### Rollout Plan

1. **Dev:** Deploy schema + code
2. **Staging:** Test with real data
3. **Production:** Deploy during low-traffic window
4. **Monitor:** Watch error logs, database performance

---

## 13. Design Decisions & Rationale

### Why Three Tables (Not Two)?

**Alternative:** Store legacy IDs directly in entity tables
```prisma
model Club {
  legacyId String?  // ❌ Pollutes entity model
}
```

**Why Rejected:**
- ❌ Pollutes core data models
- ❌ Not all entities have legacy IDs
- ❌ Hard to track import batches
- ❌ Can't rollback easily

**Chosen Design:**
- ✅ Separation of concerns (mapping vs data)
- ✅ Clean entity models
- ✅ Easy to delete all import metadata
- ✅ Tracks import job context

### Why Store legacyData (JSON)?

**Purpose:** Debugging aid
- Compare original vs imported data
- Diagnose why import failed
- Re-import with corrections

**Trade-off:**
- ✅ Invaluable for debugging
- ✅ Disk space is cheap
- ❌ Increases storage (marginal)

---

## 14. Compliance & GDPR

### Data Retention

**Import Jobs:**
- Retain for 90 days (configurable)
- Auto-delete old jobs (cron task)

**Mappings:**
- Retain indefinitely (needed for data integrity)
- Delete only when organization deleted

**Legacy Data (JSON):**
- May contain PII (names, emails)
- Option to purge after successful import
- GDPR right-to-erasure support

---

## Usage Examples

### Example 1: Import Clubs via UI

1. **Navigate** to `/app/import`
2. **Configure Job:**
   - Name: "Derby Rangers Clubs Import"
   - Entity Type: LMSPRO_CLUB
   - Description: "Importing 25 clubs from Excel export"
   - Source System: "Legacy LeagueManager"
3. **Upload CSV:**
   ```csv
   club_id,club_name,short_name,fa_number,contact_email
   1,Manchester United,Man Utd,FA12345,contact@manutd.com
   2,Liverpool FC,Liverpool,FA67890,info@liverpool.com
   ```
4. **Validate:** System shows errors/warnings
5. **Execute:** Import runs in transaction
6. **Review:** Check success/failure counts, view errors

### Example 2: Export Clubs with Legacy IDs

1. **Navigate** to `/app/export`
2. **Select Options:**
   - Entity Type: LMSPRO_CLUB
   - Format: CSV
   - Season: 2024/25 (optional)
3. **Download:** Browser downloads `lmspro_club_export_2026-01-06.csv`
4. **Result:**
   ```csv
   club_id,club_name,short_name,fa_number,season,team_count,status
   1,Manchester United,Man Utd,FA12345,2024/25,4,APPROVED
   2,Liverpool FC,Liverpool,FA67890,2024/25,3,APPROVED
   ```
   Note: `club_id` is original legacy ID for re-import compatibility

### Example 3: Programmatic Import via tRPC

```typescript
import { trpc } from '@/lib/trpc/client';

// Create import job
const job = await trpc.import.createJob.mutate({
  name: 'Venue Import',
  entityType: 'LMSPRO_VENUE',
  seasonId: 'season-uuid',
  description: 'Q1 2026 venues',
});

// Validate data
const validation = await trpc.import.validateData.mutate({
  importJobId: job.id,
  data: csvData, // Array of objects
});

if (validation.valid) {
  // Execute import
  const result = await trpc.import.executeImport.mutate({
    importJobId: job.id,
    data: csvData,
  });
  
  console.log(`Success: ${result.successCount}, Failed: ${result.failureCount}`);
}
```

### Example 4: Rollback Failed Import

```typescript
// Via UI: View job in /app/import/jobs, click "Rollback"

// Programmatically:
const result = await trpc.import.rollback.mutate({
  importJobId: 'job-uuid',
});

console.log(`Rolled back ${result.deletedCount} records`);
```

### Example 5: Create Custom Handler

```typescript
// src/modules/mymodule/import/handlers/team.ts
import { ImportHandler } from '@/lib/import/types';
import { ImportEntityType } from '@prisma/client';

export const teamImportHandler: ImportHandler<TeamData> = {
  entityType: ImportEntityType.LMSPRO_TEAM,
  
  async validate(data, context) {
    const errors = [];
    // Validation logic
    return { valid: errors.length === 0, errors, warnings: [] };
  },
  
  async import(data, context) {
    // Import logic with transaction
    return { successCount: 0, failureCount: 0, results: [] };
  },
  
  async export(filters, context) {
    // Export logic
    return [];
  },
};

// Register handler
import { registerImportHandler } from '@/lib/import/registry';
registerImportHandler('LMSPRO_TEAM', teamImportHandler);
```

---

## Troubleshooting

### Issue: "No import handler registered for entity type"

**Cause:** Handler not registered at server startup  
**Solution:** 
1. Ensure handler file imported in `src/server/core/routers/index.ts`
2. Add side-effect import: `import '~/modules/<module>/import';`
3. Verify handler calls `registerImportHandler()` at top level

### Issue: Validation passes but import fails

**Cause:** Race condition or database constraint  
**Solution:**
1. Check import job errors: `trpc.import.getJob.useQuery({ id: jobId })`
2. Review per-row errors in results array
3. Common causes:
   - Missing season (LMSPro entities require season)
   - Duplicate natural keys
   - Foreign key constraint violations

### Issue: Import succeeds but can't find imported records

**Cause:** Multi-tenant isolation (wrong organizationId)  
**Solution:**
1. Verify session user's organizationId matches import job
2. Check legacy mappings: `trpc.import.getJobMappings.useQuery({ importJobId })`
3. Use mapping to query: Get `newId` from mapping, query entity by UUID

### Issue: Export includes UUID instead of legacy ID

**Cause:** No legacy mapping exists for that record  
**Solution:**
- Expected behavior for records created directly (not imported)
- Export handler falls back to UUID when no mapping found
- To preserve legacy IDs: Always import entities before exporting

### Issue: TypeScript error "ImportEntityType not found"

**Cause:** Prisma Client cache not regenerated  
**Solution:**
1. Run: `npx prisma generate`
2. Restart TypeScript server in VS Code
3. If persists, clear Prisma cache: `rm -rf node_modules/.prisma && npx prisma generate`

---

## Summary

The Import/Export system uses a three-table architecture (ImportJob, LegacyKeyMapping, Entities) to enable safe, traceable, and reversible data migration from legacy systems. Key design choices prioritize data integrity, multi-tenancy, and auditability.

**Implementation Complete:** All phases (0-7) implemented with 45 passing tests. Frontend UI provides guided import wizard and job management. Backend supports validation, execution, rollback, and export with CSV/JSON formats.

**Key Files:**
- **Backend:** `src/server/core/routers/import.router.ts` (9 endpoints)
- **Frontend:** `src/app/(app)/app/import/page.tsx` (wizard), `src/app/(app)/app/export/page.tsx`
- **Library:** `src/lib/import/` (parser, registry, types)
- **Example Handler:** `src/modules/lmspro/import/handlers/club.ts`
- **Tests:** `src/lib/import/__tests__/`, `src/modules/lmspro/import/handlers/__tests__/`

**Next Steps:**
- Add navigation links to Import/Export pages
- Deploy to techtest with migration: `20260106184110_add_import_export_system`
- Create additional handlers for other entity types (Team, Venue, Referee, Player)
