
---
title: New IsoStack Module — Architecture Template
version: 1.1.0
status: active
last_updated: 2025-12-08
description: Requirements and design contract for any new module added to the IsoStack platform
---

# New IsoStack Module — Architecture Definition

This document is the **template and checklist** for designing and implementing any new IsoStack module.

A “module” is a self-contained application that runs **inside** IsoStack Core:

- Uses the shared **AppShell** and navigation
- Respects **multi-tenant** rules
- Integrates with **search & fuzzy logic**, **settings**, **feature flags**, and **security**
- Conforms to the **IsoStack UX Standard** and **Core Architecture** documents.

---

## 1. Purpose of the Module

**Describe the module in 2–3 sentences:**

- What problem does this module solve?
- Who uses it (platform owner, tenant admin, end users)?
- What is the primary output (dashboards, reports, workflows, APIs, etc.)?

> Example (Bedrock-style):
> “This module provides configurable analytics and dashboards powered by Google Sheets data. Tenant admins configure projects and mappings; end users consume dashboards and exports.”

---

## 2. Module Responsibilities and Boundaries

### 2.1 In-scope

List what the module **does own**:

- Domain entities (e.g. projects, sheets, questions, tasks)
- Business logic specific to this domain
- Module-specific dashboards
- Module settings and configuration
- Integrations that are unique to this module

### 2.2 Out-of-scope

List what the module **must not** own:

- Authentication and user accounts (owned by Core)
- Tenancy and organisation management (Core)
- Module branding for header/UI (owned by Core via `module_catalogue`)
- Organization White Label branding (Core/ENTERPRISE feature)
- Global platform settings and email configuration (Core)
- Search and fuzzy logic "engine" itself (Core feature)
- Generic file storage (Core/R2)
- Feature flag infrastructure (Core)

The module **consumes** these platform capabilities; it does not recreate them.

---

## 3. Integration with IsoStack Core

Every module must register itself with Core using the following information:

- `id` (string, unique)
- `slug` (URL-safe identifier, e.g., "bedrock", "tailoraid")
- `name` (human-readable name)
- `description` (optional, module purpose)
- `icon` (Tabler icon name, e.g., "IconDatabase")
- **Branding** (configured by Platform Owner at `/platform`):
  - `lightLogoUrl` (light mode logo, uploaded to R2)
  - `darkLogoUrl` (dark mode logo, uploaded to R2)
  - `faviconUrl` (module favicon, uploaded to R2)
  - `primaryColor` (hex color, e.g., "#228BE6")
  - `secondaryColor` (hex color, e.g., "#15AABF")
  - `typographyColor` (hex color, e.g., "#495057")
- **Routes**:
  - `platformRoute?` (optional, e.g., "/platform/bedrock")
  - `tenantRoute?` (optional, e.g., "/tenant/[id]/bedrock")
  - `userRoute` (main entry, e.g., "/app/bedrock")
- `category` (optional, e.g., "Data", "Integration")
- `enabled` (boolean, can module be activated)
- `isPremium` (boolean, requires premium tier)
- `isTrial` (boolean, available in trial mode)

The module must:

- Appear in the **module switcher** in the Header (if user has >1 module)
- Use routes that respect the current **scope**:
  - **Platform**: `/platform/<moduleSlug>` (Platform Owner only)
  - **Tenant**: `/tenant/[orgId]/<moduleSlug>` (NOT CURRENTLY USED)
  - **User/App**: `/app/<moduleSlug>` (standard user access)
- Display correct branding based on context:
  - **Platform Owner in `/platform`** → IsoStack Platform branding
  - **White Label org (ENTERPRISE)** → Organization branding (uploaded at `/settings/branding`)
  - **Standard org** → Active module branding (from `module_catalogue`)
  - **Fallback** → IsoStack default branding

**Critical**: No module may bypass or replace the core AppShell. The Header automatically shows the correct logo/colors based on branding priority.

---

## 4. Data Model & Schema

### 4.1 Schema Location

- All module-specific tables live in a dedicated **PostgreSQL schema**, e.g. `bedrock`, `tailoraid`, `emberbox`.
- Module metadata (name, branding, routes) lives in **`public.module_catalogue`** (managed by Core).
- IsoStack Core never writes directly into module schemas.
- Modules never write directly into **each other's** schemas.
- Module activation per organization is tracked in **`public.organisation_modules`**.

### 4.2 Primary Entities

List your main tables and their responsibilities.

For each entity:

- **Name** (Prisma model + table)
- **Purpose**
- **Key fields** (IDs, names, foreign keys)
- **Relationships** (one-to-many, many-to-many, via linking tables)

Example:

- `Project`
  - Owns the high-level definition (name, description, owner)
  - Foreign key to `Organisation`
- `Sheet`
  - Belongs to a Project
  - Stores metadata about an external data source
- `Column`
  - Belongs to a Sheet
  - Stores mapping / configuration data

### 4.3 Module Branding Registration

**Platform Owner configures module branding** at `/platform` Settings → Select Module:

- Upload light/dark logos and favicon (stored in R2 at `branding/{orgId}/{assetType}-{timestamp}.{ext}`)
- Set primary/secondary/typography colors
- Updates `module_catalogue` table
- **Standard organizations automatically inherit module branding**
- **ENTERPRISE organizations with White Label feature** can override with custom org branding

**Module developers must NOT**:
- Hard-code logos or colors in module code
- Create separate branding configuration UIs
- Use placeholder logic like `if (module === 'bedrock')` for branding

**Instead**: Trust that `useAppBranding()` hook provides correct branding based on:
1. White Label org branding (if ENTERPRISE)
2. Module branding (from `module_catalogue`)
3. IsoStack default

### 4.4 Tenancy Link

Every module entity that is tenant-specific must be linked either:

- Directly to `organisationId`, or  
- Indirectly through a parent that is linked to `organisationId`.

Row Level Security (RLS) must always be enforceable from `organisationId`.

---

## 5. Security & Row-Level Security

Each module must define a **clear security model**:

- Which roles can:
  - View
  - Create
  - Edit
  - Delete
- How RLS ensures users only see data belonging to:
  - Their organisation
  - Their roles/permissions
- How impersonation (Platform Owner “view as user”) interacts with this module

**RLS Policies:**  
For each table, specify:

- RLS enabled: yes/no (almost always **yes**)
- Policy for read
- Policy for write
- Policy for delete

Impersonation is enforced via Core, but the module must assume:

- `current_user` may be acting on behalf of someone else
- Audit logs must always record the **real actor** if written from module code

---

## 6. UI Contract

The module must **never** define its own global layout. It must:

- Use the **IsoStack AppShell** (managed by Core layout wrappers)
  - Header shows: logo (auto-selected light/dark), module name, context badge, module switcher (if applicable), user menu
  - Navbar shows: module navigation links, role-based menu items, collapse toggle (⌘B)
  - Layout automatically wraps module pages via `(app)/layout.tsx`
- Use standard **tabs**, **lists**, **modals**, and **child pages** as defined in the UX standard
- Conform to the **management hierarchy** pattern for admin-style containers where appropriate
- **Never render elements above the Mantine AppShell.Header** (60px height)
- Module pages render inside `AppShell.Main` with automatic padding and scroll

### 6.1 Branding Integration

**Modules should NOT manually implement branding logic.** The Core AppShell handles this automatically:

```typescript
// ❌ WRONG - Module tries to handle branding
import { useBranding } from './my-module-branding';
const logo = getModuleLogo();

// ✅ CORRECT - Core provides branding via AppShell
// Module pages are wrapped by (app)/layout.tsx
// Header automatically shows correct logo/colors
// No module code needed!
```

**If module needs branding context** (rare cases like emails, exports):

```typescript
import { useAppBranding } from '@/core/features/branding/useAppBranding';

function MyModuleComponent() {
  const { branding } = useAppBranding();
  // branding.logo - auto-selected light/dark
  // branding.primaryColor
  // branding.secondaryColor
  // branding.name
}
```

### 6.2 Entry Screens

Specify the first screens when the user enters the module:

- **Platform scope** (if applicable):
  - e.g., "Module configuration overview across all tenants"
  - Only accessible to Platform Owner
- **User/App scope** (primary):
  - e.g., "Module dashboard showing user's tasks/data"
  - Standard entry point for all users

**Note**: Tenant scope (`/tenant/[id]/<module>`) is reserved for future multi-tenant admin features but not currently active.

### 6.3 Tabs

Define the main **tab structure** for the user/app view.

Example:

```text
[ Overview ] [ Projects ] [ Data ] [ Settings ]
```

For each tab:

* Purpose
* Main components (lists, panels, charts)
* Whether it uses lists that require search & sort

Child pages that belong to a tab must **inherit** that tab row where the entity is a domain entity (see UX Standard).

For admin/management containers (e.g. Clients, Module Users), use the **Management Hierarchy Pattern**:

* List in a top-level tab
* Click row → full management page with its own tabs
* Tabs **replace** the parent tab set for that domain

---

## 7. Lists, Tables & Search Behaviour

Every list or table inside the module must:

* Use the **shared list control bar**:

  * Search field
  * Sort dropdown (visible columns only)
  * Sort direction toggle
* Implement **fuzzy search by default** (unless explicitly configured otherwise)

### 7.1 Search & Fuzzy Logic Settings

The module **must not** invent its own search settings model.

Instead, it uses the effective settings resolved via Core:

> `OrganisationModuleSearchSettings` → `OrganisationSearchSettings` → `PlatformSearchSettings`

For any table in this module:

* Search behaviour must respect:

  * `mode` (fuzzy, exact, hybrid)
  * `sensitivity`
  * `maxResults`
* Lists with small datasets (≤ ~1000 rows):

  * Prefer client-side fuzzy filtering
* Lists with large datasets (> ~1000 rows, or performance critical):

  * Must support server-side search via tRPC/Prisma with:

    * `searchTerm`
    * `mode`
    * `sensitivity`
    * `maxResults`
    * `sortField`
    * `sortDirection`

### 7.2 Sort Behaviour

Per table:

* Declare which fields can be sorted
* Ensure sort is applied **after** filtering for client-side lists
* Reflect sort options only for **visible columns**

### 7.3 No Ad-hoc Search UIs

The module must **not**:

* Add bespoke search bars with different behaviour
* Use different key-bindings or semantics
* Hide the standard search/sort controls

Any module-specific tweaks (e.g. advanced filters) must sit **alongside** the standard control bar, not instead of it.

---

## 8. Module Settings

Each module must expose a **Settings** tab in the tenant scope:

* This lives under the module’s main tab set:

  * e.g. `[ Overview ] [ Data ] [ Settings ]`
* It must integrate with the **Platform Settings** hierarchy:

### 8.1 Search & Fuzzy Logic (Module Level)

If Core allows module overrides for this module:

* Show:

  * Toggle: `Use custom search settings for this module`
  * Fields:

    * `mode`
    * `sensitivity`
    * `maxResults`
* Show a clear indication of where the effective settings are coming from:

  * “Using: Module override / Organisation override / Platform default”

If Core **does not** allow module overrides:

* Show read-only effective values
* Show explanation: “Module-level search overrides are disabled by your platform provider.”

### 8.2 Other Settings

Specify other module settings:

* API keys (module-specific)
* Integration toggles
* Behaviour flags
* Limits, quotas, thresholds

Settings must:

* Use standard IsoStack form and save patterns
* Avoid inline “micro-settings” scattered around the UI

---

## 9. tRPC & API Surface

Define the tRPC routers the module will expose:

* `moduleName.routerName` (e.g. `bedrock.projects`, `tailoraid.questions`)
* For each procedure:

  * Input schema (Zod)
  * Output schema
  * Authentication/authorisation requirements
  * Whether it supports:

    * Server-side search
    * Pagination
    * Sorting

Rules:

* All tRPC procedures must respect:

  * `organisationId`
  * Current user permissions
* No unauthenticated or cross-tenant queries

Where server-side search is used, tRPC must accept the standard search parameters (see Section 7.1).

---

## 10. Observability & Logging

Every module must:

* Write meaningful entries to **AuditLog** for:

  * Creation / update / deletion of key entities
  * Import/export operations
  * Security-sensitive changes (permissions, roles, sharing)
* Use structured logs where appropriate (for debugging).

For impersonation:

* Logs must indicate:

  * Real acting user
  * Impersonated user
  * Organisation and module

---

## 11. Feature Flags

If the module has features that may be toggled:

* Define them as **feature flags**, not ad-hoc conditionals
* Register flags via `getFeatureFlags()`
* Provide:

  * Key
  * Label
  * Description
  * Scope (platform, organisation, module)
* Module code reads feature flags from a Core-provided hook or context

Avoid:

* Hard-coded `if (process.env.SOME_FLAG)` sprinkled through UI and logic
* Multiple uncoordinated settings that are essentially feature toggles

---

## 12. Documentation Requirements

Each new module must ship with:

1. **Module Overview**

   * Positioning, purpose, who it is for

2. **Architecture** (this document, module-specific)

   * Entities, relationships, key flows

3. **UX & Screens**

   * Screenshots or wireframes for:

     * Entry screens (platform/tenant/user)
     * Tab structure
     * Lists and search
     * Settings pages

4. **API Reference**

   * tRPC procedures and inputs/outputs
   * Any public-facing HTTP endpoints (if applicable)

5. **Onboarding Guide**

   * How a tenant admin sets up the module
   * Typical configuration steps

These documents should live under:

```text
/docs/modules/<moduleId>/
```

---

## 13. AI & Co-pilot Guidance

When using AI to generate or modify module code:

* Always remind the AI of:

  * Core AppShell & navigation patterns
  * Search & fuzzy logic hierarchy
  * No elements above Mantine Header
  * Use of shared list controls and modals

AI prompts should:

* Reference this module architecture document
* Reference the core `architecture.md` and `isostack-ux-ui-standard.md`
* Ask for phased, testable changes
* Avoid speculative or “magic” solutions not grounded in these standards

---

## 14. Acceptance Checklist (New Module Ready)

Before a new module is considered ready:

**Core Integration:**
* [ ] Module registered in `module_catalogue` (slug, name, description, icon, routes)
* [ ] Initial branding uploaded by Platform Owner (light/dark logos, colors)
* [ ] Module appears in module switcher for multi-module orgs
* [ ] Module respects White Label org branding (if ENTERPRISE)
* [ ] No hard-coded branding in module code (uses `useAppBranding()` if needed)

**Data & Security:**
* [ ] Schema defined with clear tenancy link and RLS
* [ ] All entities properly scoped by `organisationId`
* [ ] tRPC endpoints enforce organization isolation
* [ ] Audit logging implemented for key actions

**UI & UX:**
* [ ] AppShell integration complete (no custom shells, no elements above Header)
* [ ] Tabs defined and consistent with UX standard
* [ ] All tables use shared list controls (search + sort)
* [ ] Fuzzy search implemented per effective settings (Platform → Organisation → Module)
* [ ] Module Settings tab present and wired to overrides (if applicable)
* [ ] Responsive layout tested (mobile, tablet, desktop)

**API & Features:**
* [ ] tRPC endpoints documented and permission-aware
* [ ] Feature flags (if any) registered and documented
* [ ] Error handling with user-friendly messages
* [ ] Loading states for async operations

**Documentation:**
* [ ] Core documentation updated under `/docs/modules/<moduleId>/`
* [ ] Architecture document completed (entities, relationships, flows)
* [ ] API reference with input/output schemas
* [ ] Onboarding guide for tenant admins

Once all boxes are ticked, the module fits cleanly into IsoStack and is safe to roll out to tenants.

```

---

If you’d like, next I can walk through this doc with you and:

- sanity-check whether it’s too restrictive or just right, and  
- suggest how Bedrock / TailorAid / Emberbox would each “fill in the blanks” differently using this template.
```
